import itertools
import copy

class Word:
    letters=""
    inverses=[]

    def __init__(self, letters, inverses):
        if len(letters)==len(inverses):
            self.letters = letters
            self.inverses = inverses
        else:
            raise Exception("Number of letters and number of inverses are not the same length")

    def __repr__(self):
        string=""
        for i in range(len(self.letters)):
            if self.inverses[i]==1:
                string=string+self.letters[i]
            if self.inverses[i]==-1:
                string=string+self.letters[i]+str(self.inverses[i])
        return string

    def __eq__(self,other):
        return (self.letters==other.letters and self.inverses==other.inverses)


    def singleReduce(self):
        newLetters=""
        newInverses=[]
        
        i=0
        while i<=len(self.letters)-2:
            if self.letters[i+1]==self.letters[i] and self.inverses[i+1]==-self.inverses[i]:
                i+=2
            else:
                newLetters+=self.letters[i]
                newInverses.append(self.inverses[i])
                i+=1

        if i==len(self.letters)-1:
            newLetters+=self.letters[len(self.letters)-1]
            newInverses.append(self.inverses[len(self.letters)-1])
                
        return Word(newLetters,newInverses)

    def reduce(self):
        while word!=word.singleReduce():
            reduced=word.singleReduce()
            self.letters=reduced.letters
            self.inverses=reduced.inverses()
            
    def reduced(self):
        newWord=self.singleReduce()
        while newWord!=newWord.singleReduce():
            newWord=newWord.singleReduce()
        return newWord
        

    def nullify(self,character):#treats a letter as if it were the identity
        #i.e. projects to the quotient group by the normal subgroup generated by character
        newLetters=""
        newInverses=[]
        
        i=0
        while i<=len(self.letters)-1:
            if self.letters[i]==character:
                i+=1
            else:
                newLetters+=self.letters[i]
                newInverses.append(self.inverses[i])
                i+=1
                
        self.letters=newLetters
        self.inverses=newInverses

    def nullified(self,character):
        newLetters=""
        newInverses=[]
        
        i=0
        while i<=len(self.letters)-1:
            if self.letters[i]==character:
                i+=1
            else:
                newLetters+=self.letters[i]
                newInverses.append(self.inverses[i])
                i+=1
                
        return Word(newLetters,newInverses)

    def usedLetters(self):
        letterList=""
        for i in range(len(self.letters)):
            if self.letters[i] not in letterList:
                letterList+=(self.letters[i])
        return sorted(letterList)


emptyWord=Word("",[])

def badlyHung(word):
    letters=word.usedLetters()
    
    for i in letters:
        if word.nullified(i).reduced()!=emptyWord:
            return False  
        
    return True


letters=["a","b","c","d"]#these have to be in alphabetical order
for n in range(2,24,2):
    print(n)
    letterIterator=itertools.product(letters, repeat=n)
    inverseIterator=itertools.product([1,-1], repeat=n)
    masterIterator=itertools.product(letterIterator,inverseIterator)

    for (l,i) in masterIterator:
        word=Word("".join(l),list(i))
        if l[0]==letters[0] and i[0]==1:#wlog specify first letter
            if sum(i)==0:
                if word==word.singleReduce():                    
                    if word.usedLetters()==letters:
                        if badlyHung(word):
                            print(word)
    
